package com.comcast.fission.handler.executor.impl.processor.operation.generator;

import com.comcast.fission.handler.executor.impl.processor.OperationWrapper;
import com.comcast.fission.handler.executor.impl.processor.OperationWrapperFactory;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theplatform.dfh.cp.api.operation.Operation;
import com.theplatform.dfh.cp.api.params.ParamsMap;
import com.comcast.fission.handler.executor.impl.context.ExecutorContext;
import com.comcast.fission.handler.executor.impl.processor.parallel.OperationConductor;
import com.comcast.fission.handler.executor.impl.processor.parallel.OperationConductorModifier;
import com.theplatform.dfh.cp.modules.jsonhelper.JsonHelper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.List;

/**
 * OperationConductor modifier for generated operations. Injects the newly created operations into the system for execution.
 */
public class GeneratedOperationsModifier implements OperationConductorModifier
{
    private static Logger logger = LoggerFactory.getLogger(GeneratedOperationsModifier.class);

    private static final TypeReference<List<Operation>> operationsListTypeReference = new TypeReference<List<Operation>>(){};
    private static final TypeReference<ParamsMap> paramsMapTypeReference = new TypeReference<ParamsMap>(){};

    public static final String OPERATION_GENERATOR = "agenda.operation.generator";

    private OperationWrapperFactory operationWrapperFactory = new OperationWrapperFactory();
    private ExecutorContext executorContext;

    public GeneratedOperationsModifier(ExecutorContext executorContext)
    {
        this.executorContext = executorContext;
    }

    /**
     * Modifies the existing operations to include the new operations (if this operation is a generator)
     * @param executorContext The context to operate with
     * @param operationWrapper The wrapper for the operation that generated new ops
     * @param operationConductor The OperationConductor to modify
     */
    @Override
    public void modify(ExecutorContext executorContext, OperationWrapper operationWrapper, OperationConductor operationConductor)
    {
        // no need to eval if this is not a generator
        if(!isOperationGenerator(operationWrapper.getOperation()))
            return;

        OperationGeneratorOutputDefinition outputDefinition = retrieveOutputDefinition(operationWrapper.getOperation());

        if(outputDefinition.getLogOnly() != null && outputDefinition.getLogOnly())
        {
            logger.info("Skipping operation injection (by request).");
            return;
        }

        GeneratedOperationData generatedOperationData = retrieveGeneratedOperationData(operationWrapper, outputDefinition);

        List<Operation> generatedOperations = generatedOperationData.getOperations();
        if(generatedOperations == null || generatedOperations.size() == 0)
        {
            logger.warn("No operations were generated by operation: %1$s", operationWrapper.getOperation().getName());
            return;
        }

        generatedOperations.forEach(op ->
        {
            OperationWrapper opWrapper = operationWrapperFactory.create(op);
            opWrapper.init(executorContext, operationConductor.getJsonContextUpdater());
            operationConductor.getPendingOperations().add(opWrapper);
        });
        executorContext.getAgendaProgressReporter().adjustOperationTotalCount(generatedOperations.size());
    }

    protected boolean isOperationGenerator(Operation operation)
    {
        return operation.getParams() != null && operation.getParams().containsKey(OPERATION_GENERATOR);
    }

    /**
     * Extracts the generated data from the payload of the completed operation
     * @param operationWrapper The operation wrapper to extract the payload from
     * @param outputDefinition The output definition details based on the operation params
     * @return The extracted generated data
     */
    protected GeneratedOperationData retrieveGeneratedOperationData(OperationWrapper operationWrapper, OperationGeneratorOutputDefinition outputDefinition)
    {
        JsonHelper jsonHelper = executorContext.getJsonHelper();
        GeneratedOperationData generatedOperationData = new GeneratedOperationData();
        try
        {
            ObjectMapper objectMapper = jsonHelper.getObjectMapper();
            JsonNode rootNode = objectMapper.readTree(operationWrapper.getOutputPayload());
            generatedOperationData.setOperations(retrieveField(objectMapper, rootNode, outputDefinition.getOperationsJsonPointer(), operationsListTypeReference,
                false, operationWrapper.getOperation().getName(), "operations"));
            generatedOperationData.setParams(retrieveField(objectMapper, rootNode, outputDefinition.getParamsJsonPointer(), paramsMapTypeReference,
                true, operationWrapper.getOperation().getName(), "params"));
        }
        catch(IOException e)
        {
            throw new RuntimeException("Failed to extract fields from operation generator.", e);
        }
        return generatedOperationData;
    }

    private <T> T retrieveField(ObjectMapper objectMapper, JsonNode rootNode, String jsonPointer, TypeReference<T> typeReference, boolean optionalField,
        String operationName, String fieldName)
    {
        // no need to lookup something that is not specified nor required
        if(jsonPointer == null && optionalField)
            return null;

        JsonNode jsonNode = rootNode.at(jsonPointer);
        if (!jsonNode.isMissingNode())
        {
            return objectMapper.convertValue(jsonNode, typeReference);
        }

        if(optionalField)
            return null;

        throw new RuntimeException(String.format("Failed to extract field %1$s for operation generator. %2$s not found in output of %3$s",
            fieldName,
            jsonPointer,
            operationName));
    }

    protected OperationGeneratorOutputDefinition retrieveOutputDefinition(Operation operation)
    {
        if(operation.getParams() != null && operation.getParams().containsKey(OPERATION_GENERATOR))
        {
            return executorContext.getJsonHelper().getObjectMapper()
                .convertValue(operation.getParams().get(OPERATION_GENERATOR), OperationGeneratorOutputDefinition.class);
        }
        return null;
    }

    public void setOperationWrapperFactory(OperationWrapperFactory operationWrapperFactory)
    {
        this.operationWrapperFactory = operationWrapperFactory;
    }

    static class GeneratedOperationData
    {
        private List<Operation> operations;
        private ParamsMap params;

        public List<Operation> getOperations()
        {
            return operations;
        }

        public void setOperations(List<Operation> operations)
        {
            this.operations = operations;
        }

        public ParamsMap getParams()
        {
            return params;
        }

        public void setParams(ParamsMap params)
        {
            this.params = params;
        }
    }
}
